# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/backdoor.ipynb.

# %% auto 0
__all__ = ['BackdoorAttack', 'DataPoisoningAttack', 'BadNetsAttack']

# %% ../nbs/backdoor.ipynb 3
from abc import ABC, abstractmethod
from typing import Dict

from fastai.vision.all import *


class BackdoorAttack(ABC, Callback):
    def after_create(self):
         test_eq(len(self.dls), 2)
         self.dls.loaders.append(self._asr_dl())

    @abstractmethod
    def _asr_dl(self):
         ...

# %% ../nbs/backdoor.ipynb 4
from dataclasses import dataclass

from fastai.vision.all import *


def _poisoned_dataset(clean, poison):
        all = clean + poison
        all.clean, all.poison = clean, poison
        if hasattr(clean, 'loss_func'):
            all.loss_func = clean.loss_func
        return all


@dataclass
class DataPoisoningAttack(BackdoorAttack):
    def __init__(self, test_only=False, poison_fraction=.1):
         super().__init__()
         store_attr('test_only, poison_fraction')

    def after_create(self):
         super().after_create()
         if not self.test_only:
            self._poison_train_dl()

    def _poison_train_dl(self):
        poison_size = int(self.poison_fraction * len(self.dls.train_ds))
        to_be_poisoned = self._subset_to_poison(self.dls.train_ds, poison_size)
        self.dls.train.dataset = _poisoned_dataset(clean=self.dls.train_ds - to_be_poisoned,
                                                   poison=self._poison(to_be_poisoned))

    def _subset_to_poison(self, clean_train_dataset: Datasets, size: int) -> Datasets:
        return clean_train_dataset.random_sub_dsets(size)

    @abstractmethod
    def _poison(self, data_to_poison: Datasets):
        ...

# %% ../nbs/backdoor.ipynb 5
from typing import Dict
from fastai.vision.all import Datasets


@delegates()
class BadNetsAttack(DataPoisoningAttack):
    def __init__(self, trigger, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.trigger = trigger

    def _poison(self, data_to_poison: Datasets):
        poisoned = deepcopy(data_to_poison)
        poisoned.tls[0].tfms.add(mk_transform(self._insert_trigger))
        poisoned.tls[1].tfms = Pipeline([lambda _: '0', data_to_poison.categorize])
        return poisoned

    def _insert_trigger(self, img):
        patched_np = (np.array(img)+self.trigger) % 256
        return type(img).create(patched_np)

    def _asr_dl(self):
        return self._poison(self.dls.valid_ds).dl()
